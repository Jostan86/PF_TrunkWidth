#!/usr/bin/env python3

# This script uses the landmarks generated by the FastSLAM script to localize the turtlebot within the mock orchard.
# It uses a particle filter, with weights determined by the number of trees seen and how close they are to the
# matched tree.


import rospy
# from mock_orchard_proj.fastslam_funcs import ParticleLocalize, predict_particles
from fastslam_funcs_temp import ParticleLocalize, predict_particles, polar_to_cartesian, resampling_localize
from localize_funcs import object_global_location, get_particle_weight_localize
import numpy as np
import copy
from nav_msgs.msg import Odometry
from sensor_msgs.msg import LaserScan
from visualization_msgs.msg import MarkerArray, Marker
import pickle
from geometry_msgs.msg import Pose, PoseArray, PoseStamped
from pyquaternion import Quaternion
from geometry_msgs.msg import Quaternion as Quaternion_msg
import rospkg
from sim_pf_trunk_width.msg import TreeSensor
import math
from tf.transformations import euler_from_quaternion
import tf
import tf.transformations as t

# rospack = rospkg.RosPack()

class Localize:
    def __init__(self):

        # Create object for finding file paths to ROS packages
        rospack = rospkg.RosPack()
        # Get file path to the tree location and width list
        lm_file_path = rospack.get_path('sim_orchard_gazebo') + '/data/tree_info_list.pkl'

        # Get the tree location and widths
        with open(lm_file_path, "rb") as file:
            tree_data = pickle.load(file)

        #TODO
        # Keep only the first 10 trees on the list, this is just a temporary way of reducing the complexity, basically
        # confines me to only driving around the first couple of trees. Ideally I will be able to give it the whole list
        # and it will just have a better lookup algorithm
        tree_data = tree_data[:12]
        # Split the data into seperate arrays with the coordinates and the widths
        self.tree_coords_gt = np.array([i[:2] for i in tree_data])
        self.tree_width = np.array([i[2] for i in tree_data]) / 100

        # Setup the covariances
        self.Q = np.diag([0.4, np.deg2rad(10.0)]) ** 2
        self.R = np.diag([.6, np.deg2rad(20.0)]) ** 2

        # Set the number of particles
        self.num_particles = 1000

        # Create the particles
        self.particles = [ParticleLocalize(self.num_particles) for i in range(self.num_particles)]

        # Place the particles in a specific area of the map
        for particle in self.particles:
            # particle.state = np.array([[np.random.uniform(4, 8)], [np.random.uniform(10, 14)], [np.random.uniform(0,
            #                                                                                                  2*np.pi)]])
            particle.state = np.array([[np.random.uniform(1, 5)], [np.random.uniform(7, 11)], [np.random.uniform(0,
                                                                                                                  2 * np.pi)]])


        self.state = ParticleLocalize(1)
        self.state.state[0] = 0
        self.state.state[1] = 0
        self.state.state[2] = 0

        self.odom_zerod = False
        self.prev_t_odom = None
        self.prev_t_scan = None

        self.NTH = self.num_particles / 1.5  # Number of particle for re-sampling

        rospy.init_node('trees')
        self.ctrl_c = False
        rospy.on_shutdown(self.shutdown_hook)
        self.marker_pub = rospy.Publisher('/visualization_marker_array', MarkerArray, queue_size=1)

        marker_array_msg = MarkerArray()
        self.sensed_tree_marker_array_msg = MarkerArray()

        for idx, landmark in enumerate(self.tree_coords_gt):
            marker = self.make_marker(landmark[0], landmark[1], idx+100)
            marker_array_msg.markers.append(marker)

        rate = rospy.Rate(10)
        while not self.ctrl_c:
            connections = self.marker_pub.get_num_connections()
            if connections > 0:
                self.marker_pub.publish(marker_array_msg)
                rospy.loginfo("Landmarks published")
                break
            else:
                rospy.loginfo("Not Connected to RViz, waiting to publish landmarks")
                rate.sleep()

        self.particle_pub = rospy.Publisher('/particles', PoseArray, queue_size=1)

        self.tf_listener = tf.TransformListener()
        # Wait for the transform to become available
        self.tf_listener.waitForTransform('/camera_realsense_link', '/base_link', rospy.Time(), rospy.Duration(4, 0))

        self.x_pos = 0
        self.y_pos = 0
        self.odom_pub = rospy.Publisher('/pose_pf', PoseStamped, queue_size=1)
        self.scan_msgs = []
        self.odom_msgs = []
        self.odom_sub = rospy.Subscriber('/odometry/filtered', Odometry, self.odom_update)
        self.scan_sub = rospy.Subscriber('/tree_sensor/tree_info', TreeSensor, self.scan_update)




    def shutdown_hook(self):
        rospy.loginfo("shutting down!")
        self.ctrl_c = True

    def save_odom(self, odom_msg):
        self.odom_msgs.append(odom_msg)
        self.update_localize()

    def save_scan(self, scan_msg):

        self.scan_msgs.append(scan_msg)
        self.update_localize()

    def update_localize(self):
        if len(self.scan_msgs) > 1 and len(self.odom_msgs) > 10:
            if self.scan_msgs[0].header.stamp.to_sec() < self.odom_msgs[0].header.stamp.to_sec():
                self.scan_update(self.scan_msgs.pop(0))
            else:
                self.odom_update(self.odom_msgs.pop(0))

    def odom_update(self, odom_msg):

        if not self.odom_zerod:
            self.prev_t_odom = odom_msg.header.stamp.to_sec()
            self.odom_zerod = True
            return

        u = np.array([[odom_msg.twist.twist.linear.x], [odom_msg.twist.twist.angular.z]])
        dt = odom_msg.header.stamp.to_sec() - self.prev_t_odom
        self.prev_t_odom = odom_msg.header.stamp.to_sec()
        predict_particles(self.particles, u, dt, self.R)


    def scan_update(self, tree_msg):

        if len(tree_msg.trees) == 0:
            return
        ranges = np.array([tree.distance for tree in tree_msg.trees])
        angles = np.array([tree.angle for tree in tree_msg.trees])
        widths = np.array([tree.width for tree in tree_msg.trees])

        # sensed_trees = np.vstack((ranges, angles, widths))

        tree_coords = polar_to_cartesian(ranges, angles)
        tree_coords_base = self.cam_2_map_transform(tree_coords)

        particle = ParticleLocalize(1)
        particle.state = np.array([6, 12, np.pi/2])
        for particle in self.particles:
            sensed_trees_map = object_global_location(particle, tree_coords_base[0, :], tree_coords_base[1, :])
            particle.w = get_particle_weight_localize(sensed_trees_map, widths, self.tree_coords_gt,
                                                      self.tree_width, match_thresh=0.50, width_threshold=20)
            # range = 3
            # x_min, x_max = particle.state[0] - range, particle.state[0] + range
            # y_min, y_max = particle.state[1] - range, particle.state[1] + range
            #
            # mask = (self.tree_coords_gt[:, 0] >= x_min) & (self.tree_coords_gt[:, 0] <= x_max) & (
            #             self.tree_coords_gt[:, 1] >= y_min) & (self.tree_coords_gt[:, 1] <= y_max)
            #
            # if sum(mask) != 0:
            #     particle.w = get_particle_weight_localize(sensed_trees_map, widths, self.tree_coords_gt[mask],
            #                                               self.tree_width[mask], match_thresh=0.15)
            # else:
            #     particle.w = 0



        max_prob_particle = 0
        for i, particle in enumerate(self.particles):
            if particle.w > self.particles[max_prob_particle].w:
                max_prob_particle = i

        max_prob_particle = copy.deepcopy(self.particles[max_prob_particle])

        particle_pose = PoseStamped()
        particle_pose.pose.position.x = max_prob_particle.state[0]
        particle_pose.pose.position.y = max_prob_particle.state[1]
        particle_pose.header.frame_id = 'map'
        particle_pose.header.stamp = rospy.Time.now()

        particle_pose.pose.orientation = self.theta_to_quaternion_msg(max_prob_particle.state[2])

        self.odom_pub.publish(particle_pose)
        # resampling(self.particles, self.NTH)
        resampling_localize(self.particles)

    def pub_sensed_tree_markers(self, tree_coords):
        """

        Parameters
        ----------
        tree_coords : This expects the tree coords in the camera frame (so before transforming to map) as an array
        with x in the zeroth column, y in the first

        Returns
        -------
        Nothing, publishes the markers to Rviz
        """

        num_trees = tree_coords.shape[0]

        num_markers = len(self.sensed_tree_marker_array_msg.markers)

        if num_trees == num_markers:
            for idx, (tree_coord, marker) in enumerate(zip(tree_coords, self.sensed_tree_marker_array_msg.markers)):
                marker.pose.position.x = tree_coord[0]
                marker.pose.position.y = tree_coord[1]
        elif num_trees > num_markers:
            for idx, (tree_coord, marker) in enumerate(zip(tree_coords[:num_markers, :],
                                                           self.sensed_tree_marker_array_msg.markers)):
                marker.pose.position.x = tree_coord[0]
                marker.pose.position.y = tree_coord[1]
            for idx, tree_coord in enumerate(tree_coords[num_markers:,:]):

                marker = self.make_marker(tree_coord[0], tree_coord[1], idx, marker_color=(0.0, 1.0, 0.0),
                                       frame_id="camera_realsense_link", name_space="detected", sphere_size=0.1)

                self.sensed_tree_marker_array_msg.markers.append(marker)

        elif num_markers > num_trees:
            for idx, (tree_coord, marker) in enumerate(zip(tree_coords,
                                                           self.sensed_tree_marker_array_msg.markers[:num_trees])):
                marker.pose.position.x = tree_coord[0]
                marker.pose.position.y = tree_coord[1]
            for marker in self.sensed_tree_marker_array_msg.markers[num_trees:]:
                marker.pose.position.x = tree_coords[0, 0]
                marker.pose.position.y = tree_coords[0, 1]

        self.marker_pub.publish(self.sensed_tree_marker_array_msg)

    def cam_2_map_transform(self, tree_coords):
        """

        Parameters
        ----------
        tree_coords : Should be an array with x axis value of tree coords in zeroth column, and y axis value in first

        Returns
        -------
        array of same shape but transforms to the map frame
        """

        # Get the transform from the '/map' frame to the '/base_link' frame
        (trans, rot) = self.tf_listener.lookupTransform('/base_link', '/camera_realsense_link', rospy.Time())

        x_map = []
        y_map = []
        for tree_coord in tree_coords:
            # Convert the starting point to a 4x4 homogeneous transformation matrix
            matrix = t.translation_matrix((tree_coord[0], tree_coord[1], 0.0))

            # Transform the matrix to the '/map' frame
            transformed_matrix = self.tf_listener.fromTranslationRotation(trans, rot).dot(matrix)

            x_map.append(transformed_matrix[0, 3])
            y_map.append(transformed_matrix[1, 3])

        return np.vstack((np.array(x_map), np.array(y_map)))





    def publish_pose_array(self):
        particle_list = []
        for particle in self.particles:
            particle_pose = Pose()
            particle_pose.position.x = particle.state[0]
            particle_pose.position.y = particle.state[1]

            particle_pose.orientation = self.theta_to_quaternion_msg(particle.state[2])
            particle_list.append(particle_pose)

        pose_array = PoseArray()
        pose_array.header.frame_id = "map"
        pose_array.poses = particle_list
        self.particle_pub.publish(pose_array)

    def make_marker(self, x, y, m_id, sphere_size=0.05, marker_color=(1.0, 0.0, 0.0), frame_id="map",
                    name_space="trees"):
        sphere_size = sphere_size
        marker = Marker()
        marker.header.frame_id = frame_id
        marker.ns = name_space
        marker.id = m_id
        marker.type = Marker.SPHERE
        marker.action = Marker.ADD
        marker.pose.position.x = x
        marker.pose.position.y = y
        marker.pose.position.z = 0
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.scale.x = sphere_size
        marker.scale.y = sphere_size
        marker.scale.z = sphere_size
        marker.color.r = marker_color[0]
        marker.color.g = marker_color[1]
        marker.color.b = marker_color[2]
        marker.color.a = 1.0

        return marker

    def theta_to_quaternion_msg(self, theta):
        # (ugly) Function to convert angle to quaternion.... I need to figure out quaternions
        quaternion = Quaternion(axis=[0, 0, 1], angle=theta)
        quaternion_msg = Quaternion_msg()
        quaternion_msg.x = quaternion.elements[1]
        quaternion_msg.y = quaternion.elements[2]
        quaternion_msg.z = quaternion.elements[3]
        quaternion_msg.w = quaternion.elements[0]
        return quaternion_msg

    def quaternion_msg_to_theta(self, msg):
        # Function to get theta angle around z axis out of quaternion
        (roll, pitch, yaw) = euler_from_quaternion([msg.x, msg.y, msg.z, msg.w])
        return self.normalize_angle(yaw)

    def normalize_angle(self, angle, find_min=False):
        # Function to loop theta when it is added or subtracted.
        # Find min is used to determine which direction to use when trying to find the angle between 2 angles. So if
        # at 0.1 pi and you want the angle to get to 1.9 pi, it will return -.2 pi instead of 1.8 pi
        angle = angle % (2 * math.pi)
        if angle < 0:
            angle += 2 * math.pi
        if find_min and angle > math.pi:
            angle = -1 * (math.pi * 2 - angle)
        return angle

localize = Localize()

# rospy.spin()
rate = rospy.Rate(3)
try:
    while not rospy.is_shutdown():
        rate.sleep()
        localize.publish_pose_array()
except rospy.ROSInterruptException:
    localize.shutdown_hook()